Sure! TypeScript has several built-in types. Here's a categorized list:

### **Primitive Types**
1. `string` â€“ Represents text values.
2. `number` â€“ Represents integers and floating-point numbers.
3. `boolean` â€“ Represents `true` or `false`.
4. `bigint` â€“ Used for large integers (e.g., `BigInt(12345678901234567890)`).
5. `symbol` â€“ Unique identifiers.
6. `null` â€“ Represents the absence of a value.
7. `undefined` â€“ Represents an uninitialized variable.

### **Object Types**
8. `object` â€“ Represents any non-primitive value.
9. `Array<T>` â€“ An array of elements of type `T` (e.g., `number[]`).
10. `Tuple` â€“ Fixed-size arrays with specific types (e.g., `[string, number]`).

### **Function Types**
11. `(param: type) => returnType` â€“ Defines a function signature.

### **Union and Intersection Types**
12. `A | B` â€“ Union type (e.g., `string | number`).
13. `A & B` â€“ Intersection type (e.g., combining types).

### **Literal Types**
14. Specific values as types (e.g., `"hello"`, `42`, `true`).

### **Type Aliases & Interfaces**
15. `type MyType = ...` â€“ Defines a type alias.
16. `interface MyInterface {}` â€“ Defines an object structure.

### **Utility and Special Types**
17. `any` â€“ Disables type checking.
18. `unknown` â€“ Like `any`, but safer (requires type checking).
19. `never` â€“ Represents unreachable code.
20. `void` â€“ Used for functions that donâ€™t return a value.
21. `readonly` â€“ Marks properties as immutable.
22. `Record<K, V>` â€“ Creates an object type with keys `K` and values `V`.
23. `Partial<T>` â€“ Makes all properties of `T` optional.
24. `Required<T>` â€“ Makes all properties of `T` required.
25. `Pick<T, K>` â€“ Picks specific keys from `T`.
26. `Omit<T, K>` â€“ Omits specific keys from `T`.

Let me know if you need more details on any of these! ðŸš€